package main

import (
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"strings"
	"time"

	"github.com/idagio/esbulk"
)

// Version of application.
const Version = "0.7.0"

func main() {

	var serverFlags esbulk.ArrayFlags

	version := flag.Bool("v", false, "prints current program version")
	cpuprofile := flag.String("cpuprofile", "", "write cpu profile to file")
	memprofile := flag.String("memprofile", "", "write heap profile to file")
	indexName := flag.String("index", "", "index name")
	docType := flag.String("type", "default", "elasticsearch doc type")
	flag.Var(&serverFlags, "server", "elasticsearch server, this works with https as well")
	batchSize := flag.Int("size", 1000, "bulk batch size")
	numWorkers := flag.Int("w", runtime.NumCPU(), "number of workers to use")
	verbose := flag.Bool("verbose", false, "output basic progress")
	gzipped := flag.Bool("z", false, "unzip gz'd file on the fly")
	mapping := flag.String("mapping", "", "mapping string or filename to apply before indexing")
	purge := flag.Bool("purge", false, "purge any existing index before indexing")
	idfield := flag.String("id", "", "name of field to use as id field, by default ids are autogenerated")
	user := flag.String("u", "", "http basic auth username:password, like curl -u")
	zeroReplica := flag.Bool("0", false, "set the number of replicas to 0 during indexing")
	maxRetries := flag.Int("retries", 3, "maximum number of retries (default 3) for HTTP requests")
	sourceDir := flag.String("dir", "", "path to directory with source JSON documents")
	deleteProcessed := flag.Bool("nokeep", false, "delete file from source directory after is processed (default is false)")

	flag.Parse()

	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}

	if *version {
		fmt.Println(Version)
		os.Exit(0)
	}

	if len(serverFlags) == 0 {
		serverFlags = append(serverFlags, "http://localhost:9200")
	}

	if *verbose {
		log.Printf("using %d servers", len(serverFlags))
	}

	runtime.GOMAXPROCS(*numWorkers)

	var username, password string
	if len(*user) > 0 {
		parts := strings.Split(*user, ":")
		if len(parts) != 2 {
			log.Fatal("http basic auth syntax is: username:password")
		}
		username = parts[0]
		password = parts[1]
	}

	defaultOptions := esbulk.Options{
		Servers:     serverFlags,
		Index:       *indexName,
		Purge:       *purge,
		Mapping:     *mapping,
		NumWorkers:  *numWorkers,
		ZeroReplica: *zeroReplica,
		GZipped:     *gzipped,
		DocType:     *docType,
		BatchSize:   *batchSize,
		Verbose:     *verbose,
		Scheme:      "http",
		IDField:     *idfield,
		Username:    username,
		Password:    password,
		MaxRetries:  *maxRetries,
	}

	counter := 0
	start := time.Now()
	var reader io.Reader

	if *sourceDir != "" {
		// process files from source directory
		files, err := ioutil.ReadDir(*sourceDir)
		if err != nil {
			log.Fatalf("failed to list directory due to %s", err)
		}

		for _, file := range files {
			if file.IsDir() {
				continue
			}

			path := filepath.Join(*sourceDir, file.Name())
			options, err := esbulk.IndexOptionsFromFilepath(path, defaultOptions)
			if err != nil {
				if filepath.Ext(path) == ".ldj" {
					log.Fatal(err)
				} else {}
					continue
				}
			}

			f, err := os.Open(path)
			defer f.Close()
			if err != nil {
				log.Print(err)
				continue
			}
			reader = f

			count, err := esbulk.CreateIndexFromLDJFile(reader, options)
			if err != nil {
				log.Print(err)
				continue
			}

			counter += count

			if *deleteProcessed {
				if err := os.Remove(path); err != nil {
					log.Print(err)
					continue
				}
			}

			if options.Verbose {
				log.Printf("finished file %q...", file.Name())
			}
		}
	} else {
		// process single file or STDIN
		reader = os.Stdin
		filename := ""
		if flag.NArg() > 0 {
			filename = flag.Arg(0)
			f, err := os.Open(filename)
			if err != nil {
				log.Fatalln(err)
			}
			defer f.Close()
			reader = f
		}

		count, err := esbulk.CreateIndexFromLDJFile(reader, defaultOptions)
		if err != nil {
			log.Fatal(err)
		}
		count += counter

		if *deleteProcessed && filename != "" {
			if err := os.Remove(filename); err != nil {
				log.Fatal(err)
			}
		}
	}

	elapsed := time.Since(start)

	if *memprofile != "" {
		f, err := os.Create(*memprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.WriteHeapProfile(f)
		f.Close()
	}

	if *verbose {
		rate := float64(counter) / elapsed.Seconds()
		log.Printf("%d docs in %s at %0.3f docs/s with %d workers\n", counter, elapsed, rate, *numWorkers)
	}
}
